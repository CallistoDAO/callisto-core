// SPDX-License-Identifier: MIT

pragma solidity ^0.8.22;

import {
    ECDSA,
    ERC20Permit,
    IERC20Permit
} from "../../../dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/extensions/ERC20Permit.sol";
import { SafeERC20 } from "../../../dependencies/@openzeppelin-contracts-5.3.0/token/ERC20/utils/SafeERC20.sol";
import { SafeCast } from "../../../dependencies/@openzeppelin-contracts-5.3.0/utils/math/SafeCast.sol";
import { ConverterToWadDebt } from "../../external/ConverterToWadDebt.sol";
import { VaultStrategy } from "../../external/VaultStrategy.sol";
import { IGOHM } from "../../interfaces/IGOHM.sol";
import { ICoolerTreasuryBorrower, IDLGTEv1, IMonoCooler } from "../../interfaces/IMonoCooler.sol";
import { IOHMSwapper } from "../../interfaces/IOHMSwapper.sol";
import { IOlympusStaking } from "../../interfaces/IOlympusStaking.sol";
import { CallistoOHMVaultBase, ERC20, IERC20, IERC20Metadata, Math } from "./CallistoOHMVaultBase.sol";
import { DEPOSIT_TYPEHASH, MINT_TYPEHASH, REDEEM_TYPEHASH, WITHDRAW_TYPEHASH } from "./CallistoVaultSigTypehashes.sol";

/**
 * @notice Mints 1 cOHM share (18 decimals) for 1 OHM (9 decimals) deposited.
 *
 * OHM is deposited into Olympus Cooler V2, gOHM is borrowed, and debt tokens are deposited into the vault strategy.
 * Yield repays Cooler V2 interest, surplus goes into the Callisto treasury.
 *
 * The initial setup uses USDS as the debt token and the strategy that deposits USDS into sUSDS (Sky Protocol) and
 * then into the COLLAR's PSM. See the contracts `VaultStrategy` and `DebtTokenMigrator` for details.
 *
 * Assumes strategy yield always covers debt interested generated by Olympus Cooler V2.
 */
abstract contract CallistoVaultLogic is CallistoOHMVaultBase, ERC20Permit {
    // ___ LIBRARIES ___

    using Math for uint256;
    using Math for uint128;
    using SafeCast for uint256;
    using SafeCast for int256;
    using SafeCast for bool;
    using SafeERC20 for IERC20;

    // ___ ENUMERATIONS ___

    /**
     * @notice Modes for obtaining gOHM from OHM.
     *
     * - `OlympusStaking`: Exchange OHM for gOHM (default).
     * - `Swap`: Use an external swapper if staking is unavailable (e.g., warm-up period active).
     * - `WaitingForWarmupPeriod`: Stake OHM, then claim gOHM after warm-up.
     */
    enum OHMExchangeMode {
        OlympusStaking,
        Swap,
        WaitingForWarmupPeriod
    }

    // ___ STRUCTS ___

    struct SignatureParameters {
        uint256 deadline;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    struct InitialParameters {
        address asset;
        address olympusStaking;
        address olympusCooler;
        address strategy;
        address debtConverterToWad;
        address debtTokenMigrator;
        uint256 minDeposit;
    }

    // ___ EVENTS ___

    event DepositsHandled(uint256 ohmAmount);

    event YieldWithdrawnToTreasury(uint256 yield);

    event GOHMExcessWithdrawn(address indexed to, uint256 gOHMAmount);

    event CoolerDebtRepaid(address indexed account, uint256 debtTokens);

    event ReimbursementClaimAdded(address indexed account, uint256 amount);

    event ReimbursementClaimed(address indexed account, uint256 amount);

    event MinDepositSet(uint256 minDeposit);

    event OHMExchangeModeSet(OHMExchangeMode mode);

    event OHMSwapperSet(address swapper);

    event OHMStaked(uint256 ohmAmount);

    event OHMStakeCancelled(uint256 ohmAmount);

    event DepositPaused();

    event DepositUnpaused();

    event WithdrawalPaused();

    event WithdrawalUnpaused();

    event DebtTokenMigrated(address newDebtToken);

    event EmergencyRedeemed(address indexed to, uint256 amount);

    // ___ ERRORS ___

    error ZeroAddress();

    error DebtTokenExpected(address unexpected);

    error ZeroValue();

    error AmountLessThanMinDeposit(uint256 assets, uint256 minDeposit);

    error NotEnoughGOHM(uint256 missingAmount);

    error AmountGreaterThanPendingOHMDeposits(uint256 ohmAmount, uint256 pendingOHMDeposits);

    error YieldWithdrawalExceedsTotalYield(uint256 totalYield);

    error StakingPeriodExists(uint256 period);

    error FailureToSetExchangeMode();

    error ZeroOHM();

    error RepaymentAmountExceedsDebt(uint256 excess);

    error NoExcessGOHM();

    error NoReimbursementFor(address account);

    error EnforcedPause();

    error ExpectedPause();

    error OnlyDebtTokenMigrator(address migrator);

    // ___ IMMUTABLES ___

    IGOHM public immutable GOHM;

    uint256 private immutable _GOHM_DECIMALS;

    /**
     * @notice Used to exchange OHM-gOHM.
     * See for details: `https://docs.olympusdao.finance/main/contracts-old/staking/#ohm-staking`.
     */
    IOlympusStaking public immutable OLYMPUS_STAKING;

    /// @notice Olympus Cooler V2 of Olympus V3.
    IMonoCooler public immutable OLYMPUS_COOLER;

    VaultStrategy public immutable STRATEGY;

    address public immutable DEBT_TOKEN_MIGRATOR;

    // ___ STORAGE ___

    IERC20 public debtToken;

    /// @dev The contract providing the function of converting from wad (of Olympus) to the debt token's decimals.
    ICoolerTreasuryBorrower private _debtConverterFromWad;

    /// @dev The contract providing the function of converting from the debt token's decimals to wad (of Olympus).
    ConverterToWadDebt public debtConverterToWad;

    uint256 public minDeposit;

    /// @notice The OHM amount awaiting to be deposited into the strategy.
    uint256 public pendingOHMDeposits;

    OHMExchangeMode public ohmExchangeMode;

    /**
     * @notice A reimbursement claim for `account` in wad terms of Olympus for `debtToken`.
     *
     * Sets when an `account` repays the vault's debt in Olympus Cooler V2 using `repayCoolerDebt`, to prevent
     * the vault's position from being liquidated. Represents a claim the account can later redeem when enough
     * `debtTokens` in the strategy.
     */
    mapping(address account => uint256) public reimbursementClaims;

    /// @dev It is only used when the `OHMExchangeMode.Swap` mode is active. See `OHMExchangeMode` for details.
    IOHMSwapper public ohmSwapper;

    /**
     * @notice The amount of OHM staked to `OLYMPUS_STAKING`. It is only used when the `OHMExchangeMode.OlympusStaking`
     * mode is active because of the non-zero warm-up period. See `OHMExchangeMode` for details.
     */
    uint256 public stakedOHM;

    bool public depositPaused;

    bool public withdrawalPaused;

    // ___ MODIFIERS ___

    modifier nonzeroValue(uint256 v) {
        require(v != 0, ZeroValue());
        _;
    }

    modifier notGreaterThanMaxWithdraw(uint256 assets, address owner) {
        if (assets > maxWithdraw(owner)) revert ERC4626ExceededMaxWithdraw(owner, assets, maxWithdraw(owner));
        _;
    }

    modifier notGreaterThanMaxRedeem(uint256 shares, address owner) {
        if (shares > maxRedeem(owner)) revert ERC4626ExceededMaxRedeem(owner, shares, maxRedeem(owner));
        _;
    }

    modifier whenWithdrawalNotPaused() {
        require(!withdrawalPaused, EnforcedPause());
        _;
    }

    // ___ INITIALIZATION ___

    /**
     * @dev All addresses should be nonzero.
     * `minDeposit` is assumed to be >= `olympusCooler.minDebtRequired()` (converted to OHM).
     */
    constructor(string memory name_, string memory symbol_, InitialParameters memory p)
        ERC20(name_, symbol_)
        CallistoOHMVaultBase(IERC20Metadata(p.asset))
        ERC20Permit(name_)
    {
        require(
            p.olympusStaking != address(0) && p.olympusCooler != address(0) && p.strategy != address(0)
                && p.debtConverterToWad != address(0) && p.debtTokenMigrator != address(0),
            ZeroAddress()
        );

        _setMinDeposit(p.minDeposit);

        IMonoCooler ocooler = IMonoCooler(p.olympusCooler);
        ICoolerTreasuryBorrower oCoolerTreasuryBorrower = ocooler.treasuryBorrower();
        IERC20 debtToken_ = oCoolerTreasuryBorrower.debtToken();
        address debtTokenAddr = address(debtToken_);
        VaultStrategy strategy = VaultStrategy(p.strategy);
        require(address(strategy.asset()) == debtTokenAddr, DebtTokenExpected(debtTokenAddr));

        IGOHM gOHM = IGOHM(address(ocooler.collateralToken()));
        GOHM = gOHM;
        _GOHM_DECIMALS = 10 ** gOHM.decimals();
        OLYMPUS_STAKING = IOlympusStaking(p.olympusStaking);
        OLYMPUS_COOLER = ocooler;
        DEBT_TOKEN_MIGRATOR = p.debtTokenMigrator;
        debtToken = debtToken_;
        STRATEGY = strategy;
        _debtConverterFromWad = oCoolerTreasuryBorrower;
        debtConverterToWad = ConverterToWadDebt(p.debtConverterToWad);
        // pendingOHMDeposits = 0;
        // ohmExchangeMode = OHMExchangeMode.OlympusStaking;
        emit OHMExchangeModeSet(OHMExchangeMode.OlympusStaking);
        // stakedOHM = 0;
        // depositPaused = false;
        // withdrawalPaused = false;

        /* Sets the permanent allowance of the vault strategy over this vault's debt tokens borrowed from
         * Olympus Cooler V2.
         */
        debtToken_.approve(p.strategy, type(uint256).max);
    }

    // ___ DEPOSIT & WITHDRAWAL ___

    // Note. The asset-to-share ratio is 1-to-1. The asset has 9 decimals, shares have 18 decimals.

    /**
     * @notice Deposits OHM `assets` and mints cOHM shares 1:1.
     *
     * @param assets Amount of OHM to deposit. (9 decimals).
     * @param receiver Address to receive cOHM.
     * @return Amount of cOHM minted to `receiver`. (18 decimals).
     */
    function deposit(uint256 assets, address receiver) external override returns (uint256) {
        uint256 shares = previewDeposit(assets);
        _depositOHM(assets, shares, receiver, msg.sender);
        return shares;
    }

    /**
     * @notice Deposits `assets` of OHM into the vault, minting a corresponding amount of cOHM (shares) to `receiver`,
     * using two EIP712 signatures to allow a third party to set `assets` as the allowance of this vault and call this
     * function on behalf of `owner`.
     *
     * @param assets Amount of OHM to deposit. (9 decimals).
     * @param receiver Address to receive cOHM.
     * @param owner Address providing OHM.
     * @param permitSignature An EIP712 permit signature of the OHM token to set `assets` as the allowance of
     *        this vault over `owner`'s OHM, given `owner`'s signed approval.
     * @param depositSignature An EIP712 signature from `owner` to allow this function to be called on behalf of
     *        `owner`. It is created using `DEPOSIT_TYPEHASH` and the parameters mentioned in it.
     * @return Amount of cOHM minted to `receiver`. (18 decimals).
     */
    function depositWithSig(
        uint256 assets,
        address receiver,
        address owner,
        SignatureParameters calldata permitSignature,
        SignatureParameters calldata depositSignature
    ) external returns (uint256) {
        uint256 shares = previewDeposit(assets);
        _depositOHMWithSig(assets, shares, receiver, owner, permitSignature, depositSignature, DEPOSIT_TYPEHASH);
        return shares;
    }

    /**
     * @notice Mints cOHM `shares` and deposits OHM 1:1.
     *
     * @param shares Amount of cOHM to mint. (18 decimals).
     * @param receiver Address to receive cOHM.
     * @return Amount of OHM deposited by the caller. (9 decimals).
     */
    function mint(uint256 shares, address receiver) external override returns (uint256) {
        uint256 assets = previewMint(shares);
        _depositOHM(assets, shares, receiver, msg.sender);
        return assets;
    }

    /**
     * @notice Mints `shares` of cOHM to `receiver`, depositing corresponding amounts of OHM (assets) into the vault,
     * using two EIP712 signatures to allow a third party to set corresponding amount of assets as the allowance of
     * this vault and call this function on behalf of `owner`.
     *
     * @param shares Amount of cOHM to mint. (18 decimals).
     * @param receiver Address to receive cOHM.
     * @param owner Address providing OHM.
     * @param permitSignature An EIP712 permit signature of the OHM token to set a corresponding amount as
     *        the allowance of this vault over `owner`'s OHM, given `owner`'s signed approval.
     * @param mintSignature An EIP712 signature from `owner` to allow this function to be called on behalf of `owner`.
     *        It is created using `MINT_TYPEHASH` and the parameters mentioned in it.
     * @return Amount of OHM deposited. (9 decimals).
     */
    function mintWithSig(
        uint256 shares,
        address receiver,
        address owner,
        SignatureParameters calldata permitSignature,
        SignatureParameters calldata mintSignature
    ) external returns (uint256) {
        uint256 assets = previewMint(shares);
        _depositOHMWithSig(assets, shares, receiver, owner, permitSignature, mintSignature, MINT_TYPEHASH);
        return assets;
    }

    /**
     * @notice Withdraws `assets` of OHM from the vault, burning corresponding amount of cOHM.
     *
     * @param assets Amount of OHM to withdraw. (9 decimals).
     * @param receiver Address to receive OHM.
     * @param owner Address burning cOHM.
     * @return Amount of shares burned. (18 decimals).
     */
    function withdraw(uint256 assets, address receiver, address owner)
        external
        override
        notGreaterThanMaxWithdraw(assets, owner)
        returns (uint256)
    {
        uint256 shares = previewWithdraw(assets);
        _withdrawOHM(assets, shares, receiver, owner, msg.sender);
        return shares;
    }

    /**
     * @notice Withdraws `assets` of OHM from the vault, burning corresponding amount of cOHM (shares), using
     * an EIP712 signature to allow a third party to call this function on behalf of `owner`.
     *
     * @param assets Amount of OHM to withdraw. (9 decimals).
     * @param receiver Address to receive OHM.
     * @param owner Address burning cOHM.
     * @param signature An EIP712 signature from `owner` to allow this function to be called on behalf of `owner`.
     *        It is created using `WITHDRAW_TYPEHASH` and the parameters mentioned in it.
     * @return Amount of shares burned. (18 decimals).
     */
    function withdrawWithSig(uint256 assets, address receiver, address owner, SignatureParameters calldata signature)
        external
        notGreaterThanMaxWithdraw(assets, owner)
        returns (uint256)
    {
        uint256 shares = previewWithdraw(assets);
        _withdrawOHMWithSig(assets, shares, receiver, owner, signature, WITHDRAW_TYPEHASH);
        return shares;
    }

    /**
     * @notice Redeems cOHM for OHM.
     * @param shares Amount of cOHM to redeem. (18 decimals).
     * @param receiver Address to receive OHM.
     * @param owner Address burning cOHM.
     * @return Amount of OHM withdrawn. (9 decimals).
     */
    function redeem(uint256 shares, address receiver, address owner)
        external
        override
        notGreaterThanMaxRedeem(shares, owner)
        returns (uint256)
    {
        uint256 assets = previewRedeem(shares);
        require(assets != 0, ZeroOHM()); // Check for rounding error since we round down in `previewRedeem`.
        _withdrawOHM(assets, shares, receiver, owner, msg.sender);
        return assets;
    }

    /**
     * @notice Burns `shares` of cOHM from the vault, withdrawing corresponding amount of OHM (assets), using
     * an EIP712 signature to allow a third party to call this function on behalf of `owner`.
     *
     * @param shares Amount of cOHM to redeem. (18 decimals).
     * @param receiver Address to receive OHM.
     * @param owner Address burning cOHM.
     * @param signature An EIP712 signature from `owner` to allow this function to be called on behalf of `owner`.
     *        It is created using `REDEEM_TYPEHASH` and the parameters mentioned in it.
     * @return Amount of OHM withdrawn. (9 decimals).
     */
    function redeemWithSig(uint256 shares, address receiver, address owner, SignatureParameters calldata signature)
        external
        notGreaterThanMaxRedeem(shares, owner)
        returns (uint256)
    {
        uint256 assets = previewRedeem(shares);
        require(assets != 0, ZeroOHM()); // Check for rounding error since we round down in `previewRedeem`.
        _withdrawOHMWithSig(assets, shares, receiver, owner, signature, REDEEM_TYPEHASH);
        return assets;
    }

    /**
     * @notice Burns cOHM and redeems proportional amount of `debtToken`.
     *
     * This function is only available if the Callisto vault position has been liquidated in Olympus Cooler V2.
     * It provides a last-resort exit for cOHM holders to claim debt tokens from the strategy based on their share of
     * the total supply.
     *
     * @param shares Amount of cOHM to redeem. (18 decimals).
     * @return Amount of `debtToken` transferred, or 0 if not available.
     */
    function emergencyRedeem(uint256 shares) external whenWithdrawalNotPaused nonzeroValue(shares) returns (uint256) {
        VaultStrategy strategy = STRATEGY;
        uint256 debtTokensDeposited = strategy.totalAssetsInvested();
        if (_isVaultPositionLiquidated(debtTokensDeposited, OLYMPUS_COOLER.accountCollateral(address(this)))) {
            /* In an emergency where the vault's position has been liquidated in Olympus Cooler V2 and there are
             * funds in the strategy.
             */
            // Amount to redeem = cOHM amount * Total funds in the strategy / Total cOHM.
            uint256 debtTokens = Math.mulDiv(shares, debtTokensDeposited, totalSupply());
            _burn(msg.sender, shares);
            strategy.divest(debtTokens, msg.sender);
            emit EmergencyRedeemed(msg.sender, debtTokens);
            return debtTokens;
        }
        return 0;
    }

    /* Deposits `assets` of OHM into the vault, minting corresponding amount of cOHM (shares).
     *
     * It is assumed that the keeper periodically handles the deposited OHM using `_processPendingDeposits()`.
     */
    function _depositOHM(uint256 assets, uint256 shares, address receiver, address owner) private {
        require(!depositPaused, EnforcedPause());
        require(assets >= minDeposit, AmountLessThanMinDeposit(assets, minDeposit));
        // Transfers `assets` of OHM from `msg.sender` and mints `shares` of cOHM to `receiver`.
        _deposit(owner, receiver, assets, shares);
        pendingOHMDeposits += assets;
    }

    function _depositOHMWithSig(
        uint256 assets,
        uint256 shares,
        address receiver,
        address owner,
        SignatureParameters calldata ps,
        SignatureParameters calldata ds,
        bytes32 depositTypehash
    ) private {
        IERC20Permit(asset()).permit(owner, address(this), assets, ps.deadline, ps.v, ps.r, ps.s);
        _validateSignature(ds, depositTypehash, assets, receiver, owner);
        _depositOHM(assets, shares, receiver, owner);
    }

    /* Withdraws `assets` of OHM from the vault to `receiver`, burning a corresponding amount of cOHM (shares) from
     * `owner`.
     *
     * The withdrawal process follows these steps:
     *
     * 0. First attempt to withdraw OHM without involving the strategy:
     *    1. If there are enough OHM tokens (`pendingOHMDeposits`) on this vault, they are withdrawn to `receiver`.
     *    2. If the vault's position is liquidated in Olympus Cooler V2 because its LTV is too high, the function
     *       attempts to directly transfer available OHM from the vault to `receiver`.
     *
     * Otherwise, the withdrawal process consists of the following steps:
     * 1. Calculate the amounts needed for the withdrawal:
     *    - The lacking OHM amount.
     *    - The gOHM amount required to obtain the lacking OHM.
     *    - The amount of `debtToken` to be repaid to obtain the required gOHM.
     * 2. Withdraw the required amount of `debtToken` from the strategy if available.
     *    If not enough debt tokens are in the strategy, attempt to transfer the lacking debt tokens from
     *    the caller. In this case, the caller can redeem the amount using `claimReimbursement` when
     *    enough debt tokens are available in the strategy.
     * 3. Repay the debt and withdraw gOHM from Olympus Cooler Loans V2.
     * 4. Unwrap gOHM to OHM using Olympus Staking.
     * 5. Transfer OHM to `receiver` and burn cOHM from `owner`.
     *
     * Warning. The yield generated by the strategy is used to repay the debt in Olympus Cooler Loans V2.
     * Remaining yield can be transferred to the Callisto treasury using `_withdrawYieldToTreasury`, which is
     * assumed to be called by the Callisto keeper or governance.
     *
     * Warning 2. The last depositor should withdraw an amount such that at least `minDeposit` is left
     * in the vault, otherwise the function reverts due to the minimum debt requirement in `OLYMPUS_COOLER`.
     * For the same reason, if there are a number of last cOHM holders who have about `minDeposit` in total,
     * they cannot withdraw. (This can occur if cOHM are received through direct transfers).
     */
    function _withdrawOHM(uint256 assets, uint256 shares, address receiver, address owner, address caller)
        private
        whenWithdrawalNotPaused
        nonzeroValue(assets)
    {
        /* 0. 1. Check if there are enough OHM on the balance of this vault, then use these OHM. Instead of obtaining
         * OHM by withdrawing debt token from the strategy and exchanging.
         */
        uint256 ohmBalance = pendingOHMDeposits;
        if (assets <= ohmBalance) {
            pendingOHMDeposits = ohmBalance - assets;
            // Transfers `assets` of OHM to `receiver` and burns `shares` of cOHM from `owner`.
            _withdraw(caller, receiver, owner, assets, shares);
            return;
        }

        /* So, there are not enough OHM on the vault balance and the lacking OHM amount should be obtained based on
         * debt tokens deposited into the strategy.
         */

        // Reset pending OHM, because the entire amount is involved in the withdrawal process.
        delete pendingOHMDeposits;

        // Get the total gOHM amount available in Olympus Cooler V2.
        IMonoCooler ocooler = OLYMPUS_COOLER;
        uint256 totalCollateral = uint256(ocooler.accountCollateral(address(this)));

        /* 0. 2. Check that it is an emergency where the vault's position is liquidated in Olympus Cooler V2, then
         * OHM can be directly transferred to the vault to make up for loss.
         * Otherwise, it is assumed to use `emergencyRedeem`.
         *
         * To prevent this emergency case, `repayCoolerDebt` should be used in time: before the position's LTV
         * in Olympus Cooler V2 reaches the liquidation level.
         */
        if (totalCollateral == 0) {
            // Transfers `assets` of OHM to `receiver` and burns `shares` of cOHM from `owner`.
            _withdraw(caller, receiver, owner, assets, shares);
            return;
        }

        /* 1. Calculate the amounts to cover the withdrawal request:
         *    1. The lacking amount of OHM required to cover the withdrawal request.
         *    2. The gOHM amount required to obtain `lackingOHM`.
         *    3. The amount in `debtToken` required to be repaid in Olympus Cooler Loans V2 to withdraw
         *       the calculated gOHM amount.
         * Also, handle the lack of the corresponding amounts.
         */
        // 1. 1. Calculate the lacking amount of OHM required to cover the withdrawal request.
        uint256 lackingOHM;
        unchecked {
            lackingOHM = assets - ohmBalance;
        }

        // 1. 2. Calculate the gOHM amount required to obtain `lackingOHM`.
        IGOHM gOHM = GOHM;
        uint256 gOHMAmountRequired = _convertOHMToGOHM(gOHM, lackingOHM);

        // Calculate the gOHM amount which can be withdrawn from Olympus Cooler V2.
        uint256 gOHMAmountToWithdraw;
        if (gOHMAmountRequired <= totalCollateral) {
            // If enough gOHM are available in Olympus Cooler V2.
            gOHMAmountToWithdraw = gOHMAmountRequired;
        } else {
            /* If not enough gOHM in Olympus Cooler V2.
             *
             * This occurs for the last depositor because of rounding in the `GOHM` contract.
             * In this case, it is assumed to use the gOHM directly transferred to the vault.
             * If not enough gOHM in the vault, revert.
             */
            if (gOHM.balanceOf(address(this)) < gOHMAmountRequired - totalCollateral) {
                revert NotEnoughGOHM(gOHMAmountRequired - totalCollateral);
            }

            gOHMAmountToWithdraw = totalCollateral;
        }

        /* 1. 3. Calculate the debt amount required to repay a debt in `OLYMPUS_COOLER` to withdraw
         * `gOHMAmountToWithdraw`.
         */
        (uint128 wadDebt, uint256 debtToRepay) = _calcDebtToRepay(ocooler, gOHMAmountToWithdraw);

        /* 2. Withdraw the required amount of `debtToken` from the strategy to repay the debt.
         *
         * If an emergency case where not enough are available in the strategy, attempting to obtain
         * the lacking amount of `debtToken` from the caller, and record a reimbursement to be claimed by
         * the caller using `claimReimbursement` when there are enough funds in the strategy.
         * If a caller would not like to pay the lacking amount, then, alternatively, the caller can withdraw
         * the part, for which the available funds are sufficient instead of the entire amount.
         *
         * Note. This also occurs if the yield generated by the strategy is not enough to repay the debt in
         * Olympus Cooler Loans V2. For example, if the first depositor attempts to immediately withdraw
         * the entire initial deposit. So, the strategy has not time to accumulate yield.
         */
        IERC20 debtToken_ = debtToken;
        _withdrawStrategyOrCallerFunds(debtToRepay, debtToken_);

        // 3. Repay the debt in Olympus Cooler V2 to withdraw gOHM.
        if (debtToRepay != 0) {
            // slither-disable-next-line unused-return
            debtToken_.approve(address(ocooler), debtToRepay);
            // slither-disable-next-line unused-return
            ocooler.repay({ repayAmountInWad: wadDebt, onBehalfOf: address(this) });
        }
        // Withdraw gOHM (the collateral) from Olympus Cooler V2.
        // slither-disable-next-line unused-return
        ocooler.withdrawCollateral({
            collateralAmount: gOHMAmountToWithdraw.toUint128(),
            onBehalfOf: address(this),
            recipient: address(this),
            delegationRequests: new IDLGTEv1.DelegationRequest[](0)
        });

        // 4. Exchange gOHM for OHM. (Note. Olympus Staking does not have a warm-up period for OHM redemption).
        IOlympusStaking ostaking = OLYMPUS_STAKING;
        // slither-disable-next-line unused-return
        gOHM.approve(address(ostaking), gOHMAmountRequired);
        // TODO: consider whether to trigger a bounty and handle it if the staking has a distributor.
        // slither-disable-next-line unused-return
        ostaking.unstake({ to: address(this), amount: gOHMAmountRequired, trigger: false, rebasing: false });

        // 5. Transfer `assets` of OHM to `receiver` and burn `shares` of cOHM from `owner`.
        _withdraw(caller, receiver, owner, assets, shares);
    }

    function _withdrawOHMWithSig(
        uint256 assets,
        uint256 shares,
        address receiver,
        address owner,
        SignatureParameters calldata s,
        bytes32 typehash
    ) private {
        _validateSignature(s, typehash, assets, receiver, owner);
        _withdrawOHM(assets, shares, receiver, owner, owner);
    }

    function _validateSignature(
        SignatureParameters calldata s,
        bytes32 typehash,
        uint256 assets,
        address receiver,
        address owner
    ) private {
        if (block.timestamp > s.deadline) revert ERC2612ExpiredSignature(s.deadline);
        address signer = ECDSA.recover(
            _hashTypedDataV4(
                keccak256(abi.encode(typehash, msg.sender, owner, receiver, assets, _useNonce(owner), s.deadline))
            ),
            s.v,
            s.r,
            s.s
        );
        if (signer != owner) revert ERC2612InvalidSigner(signer, owner);
    }

    /* Withdraws funds from the strategy (up to available), transfers the rest from the caller, and records
     * a reimbursement for the caller.
     */
    function _withdrawStrategyOrCallerFunds(uint256 debtToRepay, IERC20 debtToken_) private {
        // Get the total amount available in the strategy.
        VaultStrategy strategy = STRATEGY;
        uint256 strategyBalance = strategy.totalAssetsAvailable();

        // If the strategy covers the entire debt, withdraw the required amount of `debtToken`.
        if (debtToRepay <= strategyBalance) {
            strategy.divest(debtToRepay, address(this));
            return;
        }

        // Otherwise, the caller pays the difference, and a reimbursement is recorded for them.
        uint256 callerContribution;
        unchecked {
            callerContribution = debtToRepay - strategyBalance;
        }
        debtToken_.safeTransferFrom(msg.sender, address(this), callerContribution);
        uint256 reimbursementClaim = debtConverterToWad.toWad(callerContribution);
        reimbursementClaims[msg.sender] += reimbursementClaim;
        emit ReimbursementClaimAdded(msg.sender, reimbursementClaim);

        // Withdraw the available amount of `debtToken` from the strategy.
        if (strategyBalance != 0) strategy.divest(strategyBalance, address(this));
    }

    /* Returns the gOHM amount for `value` increased by `1` if the remainder is greater than zero.
     *
     * Note. Here, `.mulDiv()` is not used to be consistent with the approach implemented in the `GOHM` contract.
     */
    function _convertOHMToGOHM(IGOHM gOHM, uint256 value) private view returns (uint256) {
        uint256 gOHMIndex = gOHM.index();
        return (value * _GOHM_DECIMALS) / gOHMIndex + SafeCast.toUint(mulmod(value, _GOHM_DECIMALS, gOHMIndex) > 0);
    }

    // ___ FUNCTION TO CORRECT THE POSITION LTV IN OLYMPUS COOLER LOANS V2 ___

    /**
     * @notice Repays vault's debt to Olympus Cooler V2 to restore max origination LTV.
     * Withdraws funds from the strategy (up to available), transfers the rest from the caller, and records
     * a reimbursement to be claimed by the caller.
     * @param amount Amount of `debtToken` to repay.
     */
    function repayCoolerDebt(uint256 amount) external {
        // Calculate the amount required to repay a debt in `OLYMPUS_COOLER` to return to the origination LTV.
        IMonoCooler ocooler = OLYMPUS_COOLER;
        (uint128 wadDebtToRepay, uint256 debtToRepay) = _calcDebtToRepay(ocooler, 0);
        if (debtToRepay == 0) return;

        if (amount != 0) {
            if (amount > debtToRepay) revert RepaymentAmountExceedsDebt(amount - debtToRepay);

            if (amount < debtToRepay) {
                debtToRepay = amount;
                wadDebtToRepay = debtConverterToWad.toWad(debtToRepay);
            }
        }

        /* Withdraw an available amount from the strategy to repay the debt. If the amount is not enough, then
         * transfer the rest from the caller and record a reimbursement for the caller.
         */
        IERC20 debtToken_ = debtToken;
        _withdrawStrategyOrCallerFunds(debtToRepay, debtToken_);

        // Repay the debt in Olympus Cooler V2 to return the position LTV to the origination LTV.
        // slither-disable-next-line unused-return
        debtToken_.approve(address(ocooler), debtToRepay);
        // slither-disable-next-line unused-return
        ocooler.repay({ repayAmountInWad: wadDebtToRepay, onBehalfOf: address(this) });
        emit CoolerDebtRepaid(msg.sender, debtToRepay);
    }

    /**
     * @notice Allows an account to claim reimbursement for `debtToken` previously supplied to repay vault debt
     * with `repayCoolerDebt`, or for covering withdrawals during emergencies
     * when the vault strategy lacked sufficient funds.
     *
     * @param account Address claiming reimbursement.
     */
    function claimReimbursement(address account) external {
        (, uint256 debt) = _debtConverterFromWad.convertToDebtTokenAmount(reimbursementClaims[account]);
        require(debt != 0, NoReimbursementFor(account));

        delete reimbursementClaims[account];

        VaultStrategy strategy = STRATEGY;
        uint256 strategyBalance = strategy.totalAssetsAvailable();
        if (debt <= strategyBalance) {
            // If enough debt tokens in the strategy to reimburse.
            strategy.divest(debt, account);
        } else {
            // If not enough debt tokens in the strategy.
            unchecked {
                debtToken.safeTransfer(account, debt - strategyBalance);
            }
            if (strategyBalance != 0) strategy.divest(strategyBalance, account);
        }
        emit ReimbursementClaimed(account, debt);
    }

    // ___ VIEWERS ___

    function totalYield() external view returns (uint256) {
        return _totalYield(STRATEGY);
    }

    function excessGOHM() external view returns (uint256) {
        return _excessGOHM({ ocooler: OLYMPUS_COOLER, requiresExcess: false });
    }

    function _treasuryAddress() internal view virtual returns (address);

    // Returns the debt amount required to be repaid in `OLYMPUS_COOLER` to withdraw `gOHMAmount`.
    function _calcDebtToRepay(IMonoCooler ocooler, uint256 gOHMAmount) private view returns (uint128, uint256) {
        int128 debtDelta = ocooler.debtDeltaForMaxOriginationLtv({
            account: address(this),
            collateralDelta: -(gOHMAmount.toInt256().toInt128())
        });
        if (debtDelta >= 0) return (0, 0);
        uint128 wadDebt = uint128(-debtDelta);
        (, uint256 debt) = _debtConverterFromWad.convertToDebtTokenAmount(wadDebt);
        return (wadDebt, debt);
    }

    // Total yield = Strategy funds - Vault's debt to Olympus Cooler V2. If vault is liquidated, yield is 0.
    function _totalYield(VaultStrategy strategy) private view returns (uint256) {
        uint256 totalDeposited = strategy.totalAssetsInvested();
        uint128 debt = OLYMPUS_COOLER.accountDebt(address(this));
        if (_isVaultPositionLiquidated(totalDeposited, debt)) return 0;
        return totalDeposited - debt;
    }

    function _excessGOHM(IMonoCooler ocooler, bool requiresExcess) private view returns (uint256) {
        uint256 gOHMIndex = GOHM.index();
        uint256 gOHMDecimals = _GOHM_DECIMALS;
        /* Total OHM that can be obtained for all available GOHM = gOHM.balanceFrom( Total GOHM ).
         *
         * Not use `gOHM.balanceFrom()` to optimize gas.
         */
        uint256 ohmAvailable = (ocooler.accountCollateral(address(this)) * gOHMIndex) / gOHMDecimals;
        uint256 ohmRequired = totalAssets() + 1; // + 1, because `totalAssets` rounds down.
        if (ohmAvailable <= ohmRequired) {
            if (requiresExcess) revert NoExcessGOHM();
            return 0;
        }

        // Calculate excess GOHM. Not use `gOHM.balanceTo()` to optimize gas.
        return ((ohmAvailable - ohmRequired) * gOHMDecimals) / gOHMIndex;
    }

    // Returns `true` in an emergency where the vault's position has been liquidated in Olympus Cooler Loans V2.
    function _isVaultPositionLiquidated(uint256 totalDeposited, uint256 debt) private pure returns (bool) {
        /* The condition `totalDeposited > 1` is used instead of `!= 0` because, in an extremely rare case,
         * 1 token unit may remain on the strategy's balance after withdrawing all OHM deposits.
         * When migrating to a debt token with lower decimals, the division rounds up to ensure
         * the Callisto vault receives exactly enough tokens to cover its debt.
         * See `DebtTokenMigrator.migrateDebtToken()` for details.
         * Any remaining token unit after withdrawing all deposits is considered as an empty balance.
         * The minimum debt requirement of Olympus Cooler Loans V2 should prevent passing this condition when
         * not liquidated.
         */
        return totalDeposited > 1 && debt == 0;
    }

    // ___ DEPOSIT PROCESSING LOGIC ___

    /**
     * @notice Processes pending OHM deposits: converts to gOHM, borrows `debtToken`, deposits into the strategy.
     *
     * Assumed to be called:
     * 1. Manually before the next `_executeByHeart` to increase the gOHM collateral in Olympus Cooler V2 so that more
     *    voting power for gOHM can be delegated in the Callisto CDP.
     * 2. When `OLYMPUS_STAKING` does not exchange OHM to gOHM without a warm-up period.
     */
    function processPendingDeposits(uint256 ohmAmount, bytes[] memory swapperData) external {
        _processPendingDeposits(ohmAmount, ohmExchangeMode, swapperData);
    }

    /* Processes OHM deposits when `OHMExchangeMode.OlympusStaking`.
     * Assumed to be called through the `execute` method used by the Callisto heart.
     */
    function _executeByHeart() internal {
        uint256 ohmAmount = pendingOHMDeposits;
        if (ohmAmount == 0) return;
        OHMExchangeMode exchangeMode = ohmExchangeMode;
        if (ohmExchangeMode != OHMExchangeMode.OlympusStaking) return;

        _processPendingDeposits(ohmAmount, exchangeMode, new bytes[](0));
    }

    /* Processes OHM deposits by depositing `ohmAmount` of OHM to Olympus Cooler Loans V2 obtaining `debtToken` and then
     * depositing them into the strategy.
     *
     * This process consists of the following steps:
    * 1. Exchanging OHM for gOHM using Olympus Staking or another approach (see `OHMExchangeMode` for more details).
     * 2. Borrowing `debtToken` for gOHM using Olympus Cooler Loans V2.
     * 3. Depositing `debtToken` into the strategy.
     */
    function _processPendingDeposits(uint256 ohmAmount, OHMExchangeMode exchangeMode, bytes[] memory swapperData)
        private
        nonzeroValue(ohmAmount)
    {
        if (exchangeMode != OHMExchangeMode.WaitingForWarmupPeriod || stakedOHM == 0) {
            /* If `OHMExchangeMode.WaitingForWarmupPeriod` and `stakedOHM` exists, the passed `ohmAmount` is replaced
             * by `stakedOHM` in the logic below, and `pendingOHMDeposits` is not reduced,
             * because `stakedOHM` is claimed from Olympus Staking after the warm-up period expires.
             *
             * Note. `_setOHMExchangeMode` prevents from changing the mode when `stakedOHM` exists.
             */

            if (ohmAmount > pendingOHMDeposits) {
                revert AmountGreaterThanPendingOHMDeposits(ohmAmount, pendingOHMDeposits);
            }

            unchecked {
                pendingOHMDeposits -= ohmAmount;
            }
        }

        // 1. Exchange OHM for gOHM.
        uint256 tmpAmount;
        if (exchangeMode == OHMExchangeMode.OlympusStaking) {
            // If gOHM can be directly obtained using `OLYMPUS_STAKING`.

            IOlympusStaking ostaking = OLYMPUS_STAKING;
            if (ostaking.warmupPeriod() != 0) revert StakingPeriodExists(ostaking.warmupPeriod());

            // Deposit `ohmAmount` of pending OHM (assets) to `OLYMPUS_STAKING` to get gOHM.
            // slither-disable-next-line unused-return
            _OHM.approve(address(ostaking), ohmAmount);
            // Returns gOHM amount.
            tmpAmount = ostaking.stake({ to: address(this), amount: ohmAmount, rebasing: false, claim: true });
        } else if (exchangeMode == OHMExchangeMode.Swap) {
            // If obtaining gOHM using `ohmSwapper` because of the non-zero warm-up period in `OLYMPUS_STAKING`.
            IOHMSwapper swapper = ohmSwapper;
            // slither-disable-next-line unused-return
            _OHM.approve(address(swapper), ohmAmount);
            tmpAmount = swapper.swap(ohmAmount, swapperData);
        } else {
            // If `exchangeMode == OHMExchangeMode.WaitingForWarmupPeriod`.
            if (stakedOHM == 0) {
                stakedOHM += ohmAmount;
                IOlympusStaking ostaking = OLYMPUS_STAKING;
                // slither-disable-next-line unused-return
                _OHM.approve(address(ostaking), ohmAmount);
                // slither-disable-next-line unused-return
                ostaking.stake({ to: address(this), amount: ohmAmount, rebasing: false, claim: false });
                emit OHMStaked(ohmAmount);
                return; // `_processPendingDeposits` should be called again after the warm-up period has elapsed.
            } else {
                ohmAmount = stakedOHM;
                delete stakedOHM;
                tmpAmount = OLYMPUS_STAKING.claim({ to: address(this), rebasing: false });
                require(tmpAmount != 0, ZeroValue());
            }
        }

        // 2. Borrow `debtToken` from Olympus Cooler Loans V2.
        IMonoCooler ocooler = OLYMPUS_COOLER;
        // slither-disable-next-line unused-return
        GOHM.approve(address(ocooler), tmpAmount);
        ocooler.addCollateral({
            collateralAmount: tmpAmount.toUint128(),
            onBehalfOf: address(this),
            delegationRequests: new IDLGTEv1.DelegationRequest[](0)
        });
        // Returns `debtToken` amount.
        tmpAmount = ocooler.borrow({
            borrowAmountInWad: type(uint128).max, // Borrow up to `_globalStateRW().maxOriginationLtv` of Cooler V2.
            onBehalfOf: address(this),
            recipient: address(this)
        });

        // 3. Deposit borrowed `debtToken` into the strategy.
        STRATEGY.invest(tmpAmount);

        emit DepositsHandled(ohmAmount);
    }

    // ___ RESTRICTED FUNCTIONALITY ___

    function _applyDelegations(IDLGTEv1.DelegationRequest[] calldata delegationRequests)
        internal
        returns (uint256, uint256, uint256)
    {
        return OLYMPUS_COOLER.applyDelegations({ delegationRequests: delegationRequests, onBehalfOf: address(this) });
    }

    function _sweepYield(uint256 yield) internal nonzeroValue(yield) {
        VaultStrategy strategy = STRATEGY;
        uint256 totalYield_ = _totalYield(strategy);

        if (yield == type(uint256).max) yield = totalYield_;
        else if (yield > totalYield_) revert YieldWithdrawalExceedsTotalYield(totalYield_);

        strategy.divest(yield, address(this));
        debtToken.safeTransfer(_treasuryAddress(), yield);
        emit YieldWithdrawnToTreasury(yield);
    }

    /* Withdraws excess gOHM.
     *
     * This function is for when Olympus enables rebasing, gOHM is starting to become more expensive relative to OHM
     * because the index is increasing.
     */
    function _withdrawExcessGOHM(uint256 gOHMAmount, address to) internal {
        // Calculate excess GOHM.
        IMonoCooler ocooler = OLYMPUS_COOLER;
        uint256 excessGOHM_ = _excessGOHM({ ocooler: ocooler, requiresExcess: true });
        if (gOHMAmount > excessGOHM_) revert NotEnoughGOHM(gOHMAmount - excessGOHM_);

        // Calculate the debt amount required to repay a debt in `OLYMPUS_COOLER` to withdraw `gOHMAmount`.
        (uint128 wadDebtToRepay, uint256 debtToRepay) = _calcDebtToRepay(ocooler, gOHMAmount);

        if (debtToRepay != 0) {
            /* If `_processPendingDeposits` is called before this function, then the borrowed amount in
             * Olympus Cooler V2 is maximized.
             * In this case, `debtToRepay` should be repaid to withdraw excess gOHM.
             */

            // Withdraw `debtToRepay` from the strategy.
            STRATEGY.divest(debtToRepay, address(this)); // Reverts, if not enough debt tokens are available.

            // Repay the debt in Olympus Cooler V2 to withdraw gOHM.
            // slither-disable-next-line unused-return
            debtToken.approve(address(ocooler), debtToRepay);
            // slither-disable-next-line unused-return
            ocooler.repay({ repayAmountInWad: wadDebtToRepay, onBehalfOf: address(this) });
        }

        // Withdraw excess gOHM from Olympus Cooler V2.
        // slither-disable-next-line unused-return
        ocooler.withdrawCollateral({
            collateralAmount: gOHMAmount.toUint128(),
            onBehalfOf: address(this),
            recipient: to,
            delegationRequests: new IDLGTEv1.DelegationRequest[](0)
        });
        emit GOHMExcessWithdrawn(to, gOHMAmount);
    }

    function _sweepTokens(address tokenAddr, address to, uint256 value) internal {
        if (tokenAddr == asset()) {
            IERC20 token = IERC20(tokenAddr);
            if (token.balanceOf(address(this)) - pendingOHMDeposits >= value) token.safeTransfer(to, value);
        } else {
            IERC20(tokenAddr).safeTransfer(to, value);
        }
    }

    function _cancelOHMStake() internal nonzeroValue(stakedOHM) {
        delete stakedOHM;
        uint256 ohmAmount = OLYMPUS_STAKING.forfeit();
        pendingOHMDeposits += ohmAmount;
        emit OHMStakeCancelled(ohmAmount);
    }

    function _setMinDeposit(uint256 minDeposit_) internal nonzeroValue(minDeposit_) {
        minDeposit = minDeposit_;
        emit MinDepositSet(minDeposit_);
    }

    /* Note. Sets OHM-gOHM exchange mode. Cannot change if OHM is in warm-up period in Olympus Staking.
     * To change the mode in such a case, `stakedOHM` should be claimed using `_processPendingDeposits` after
     * the warm-up period has expired or withdrawn using `_cancelOHMStake`.
     */
    function _setOHMExchangeMode(OHMExchangeMode mode) internal {
        require(mode != ohmExchangeMode, FailureToSetExchangeMode());
        if (mode != OHMExchangeMode.WaitingForWarmupPeriod) require(stakedOHM == 0, FailureToSetExchangeMode());
        if (mode != OHMExchangeMode.OlympusStaking) {
            require(OLYMPUS_STAKING.warmupPeriod() != 0, FailureToSetExchangeMode());
        } else {
            require(OLYMPUS_STAKING.warmupPeriod() == 0, FailureToSetExchangeMode());
        }

        ohmExchangeMode = mode;
        emit OHMExchangeModeSet(mode);
    }

    function _setOHMSwapper(address swapper) internal {
        require(swapper != address(0), ZeroAddress());
        ohmSwapper = IOHMSwapper(swapper);
        emit OHMSwapperSet(swapper);
    }

    function _setPause(bool deposit_, bool pause) internal {
        if (deposit_) {
            if (pause) {
                require(!depositPaused, EnforcedPause());
                depositPaused = true;
                emit DepositPaused();
            } else {
                require(depositPaused, ExpectedPause());
                depositPaused = false;
                emit DepositUnpaused();
            }
        } else if (pause) {
            require(!withdrawalPaused, EnforcedPause());
            withdrawalPaused = true;
            emit WithdrawalPaused();
        } else {
            require(withdrawalPaused, ExpectedPause());
            withdrawalPaused = false;
            emit WithdrawalUnpaused();
        }
    }

    // ___ DEBT TOKEN MIGRATION LOGIC ___

    function migrateDebtToken(address newDebtToken, address newConverterToWadDebt) external {
        require(msg.sender == DEBT_TOKEN_MIGRATOR, OnlyDebtTokenMigrator(DEBT_TOKEN_MIGRATOR));

        IERC20 newDebtToken_ = IERC20(newDebtToken);
        debtToken = newDebtToken_;
        _debtConverterFromWad = OLYMPUS_COOLER.treasuryBorrower();
        debtConverterToWad = ConverterToWadDebt(newConverterToWadDebt);

        /* Set the permanent allowance of the vault strategy over this vault's debt tokens borrowed from
         * Olympus Cooler V2.
         */
        newDebtToken_.approve(address(STRATEGY), type(uint256).max);

        emit DebtTokenMigrated(newDebtToken);
    }
}
